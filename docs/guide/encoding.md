## 数据可用性编码

数据经过编码后，只要通过其中任意 50% 数据，即可恢复原始数据。这听起来很高级，实际上原理非常简单。接下来我们不得不使用一些公式，请不用走开，真的非常简单。

我们有一小段原始数据，我们将其分割为两部分，并视为数字，分别用 $y_1$ 和 $y_2$ 表示，并视为在一条直线上当 $x_1 = 1$ 和 $x_2 = 2$ 时的 $y$ 值，我们通过这两个点就可以画出一条直线：

我们用如下形式表示这条唯一的直线：

$$
y=ax+b
$$

对原始数据进行编码，就是再取 $x$ 分别为 $3,4$ 时 $y$ 的值，从而得到：

$$
[y_1,y_2,y_3,y_4]
$$

两点确定一条直线，我们只需要知道这条直线上的两个点，就可以画出这条直线。换句话说，我们只需要其中两个 $y$ 的值，就可以计算出 $a$ 和 $b$ 的值。无论 $y$ 的值丢失了哪两个，我们都能恢复出原始数据。

在实际应用中，原理有很大出入。另外，现实中的数据远比两个数字复杂得多，它可能是上千个交易、上万条状态变更，我们无法仅仅用一条直线去表示它们。但没关系，我们早就有了通用方法：**多项式插值和纠删码（Erasure Coding）**。在这类编码方式中，最常被使用的是 **Reed-Solomon 编码**（RS 编码），它广泛用于光盘、硬盘、卫星通信等需要高容错的数据场景，例如当光盘有轻微的划痕时，我们还能读取出数据。只要你手上有足够多的“点”，就可以准确还原出原始数据。

## 编码证明

现在我们回顾下采样的流程，采样者试图从点对点网络中获得某个坐标的数据，多次采样后以获得数据是否可用的信心保证。现在还有一个问题： 我们如何确保采样获得的数据块就是发布者的原始数据块，而不是经过篡改的？

### 数据指纹

我们通过叠加数据指纹的方式来做到这一点，每个数据块都生成一个独特的指纹，之后我们再将这些指纹当做数据，两两合并生成新的指纹，如此一来指纹数量少了一半，如此多次最终我们将得到一个单独的指纹。这个最终的指纹被称为默克尔根，整个指纹叠加的方式就像一颗树，被称为默克尔树。

[图示： 默克尔树]

我们只需要公布从树的叶子到根经过的所有叶子，就可以验证该数据是否被经过了篡改。数据发布者只需要公布默克尔根，并为每个数据块生成一个证明，就可以保证数据在网络中原样传递。这个默克尔根会被保存在链上，作为这个批交易的数据指纹。在乐观 Rollup 中，发起挑战时，只需要提交数据块，以及这个数据块相对于默克尔根的证明。

### 欺诈证明

但数据指纹并不能保证所有数据都是正确的，回顾一下我们的正确数据：

$$
[y_1,y_2,y_3,y_4]
$$

我们使用它来生成一个默克尔根 $root$ 。假设其中的 $y_2$ 是一笔恶意交易，Alice 的余额为 20ETH ，但成功向 Bob 转账了 100ETH 。在乐观 Rollup 中，我们只需要向链上提交原始数据 $y_2$ 发起挑战，便得使这笔交易作废。

现在 Alice 作为数据发布者，用一个错误的数据 $z$ 代替原始数据，从而生成新的默克尔根 $root'$ 并公开。

$$
[y_1,z,y_3,y_4]
$$

之后 Alice 隐藏数据 $z$ 的值，只发布其他所有数据。此时超过 50% 的数据被公布，可以通过采样，但没人知道 $z$ 的值是什么。这听起来似乎没什么问题，因为我们可以通过其他的值恢复出原始的正确 $y_2$ ，但无法生成  $y_2$ 相对于 $root'$ 的证明，我们无法发起挑战。当然 $z$ 也是错误的，也可以通过它来发起挑战，但挑战者无法知道 $z$ 的值，同样无法发起挑战。最终，这笔错误的交易将无法被识别。

解决方案是使用欺诈证明。

这依赖于一个强大的全节点，能够获取大部分数据并恢复，重新编码后即可发现 $root'$ 是错误的。全节点将生成一个欺诈证明，包含了一半的数据（用于恢复完整数据）、数据块的证明和错误之处。网络中的采样节点在采样成功后，并不急于确认数据是可用的，而是留出一定的时间等待欺诈证明。如果收到欺诈证明并通过验证，整个数据将被视为不可用，随后节点向其他节点继续传播欺诈证明。如果在等待期完成后依然没有收到欺诈证明，即可确定数据是可用的。

当然这是一个十分简化的示例，在现实中，数据的错误编码方式更多，攻击方式也更多。

### 多项式承诺

欺诈证明仍然不够优雅，它存在以下问题：

1. 依赖于一个强大的全节点，这增加了网络的中心化程度，如果少量的全节点遭受到攻击，无法发出欺诈证明，将使得不可用的数据被误认为可用。
2. 如果采样节点没有连接到至少一个诚实节点，将无法接受到欺诈证明，这也被称为日蚀攻击。这是一个致命的问题，但不是其缺陷，因为日蚀攻击的风险普遍存在于点对点网络中。

除此之外，还有一个更恼人问题： 实际应用中数据往往非常大，带来默克尔树的层级很大，使得证明本身就非常大，早就超过数据块本身的大小，这将使得整个系统非常低效。我们可以一次性解决以上所有问题，这就是一种被称为多项式承诺的技术。

回想一下恶意用于是如何通过默克尔证明来作弊的，对方构造了一个虚假的点 $(x_2, z)$ ，并和合法的数据一起生成新的默克尔根，使得系统认为虚假数据是合法的。本质上，这是由于默克尔树只对数据本身负责，而无法识别背后的直线。多项式承诺的不同之处在于，它不是为数据生成指纹，而是为直线本身生成指纹，我们称为承诺。直线上的每个点都可以生成一个证明，我们只需要数据块、证明、承诺就可以验证其合法性，作弊者无法为一个虚假的 $z$ 生成证明来通过验证。

多项式承诺还带来了另一个好处，证明相对小得多，而且我们还可以通过子向量证明让多个数据块共用同一个证明，这对采样和存储来说十分高效。

自此，我们不再需要欺诈证明高效地实现数据可用性。