# 椭圆曲线应用

## ECDH 密钥协商

现在我们有了一对私钥和公钥，别人无法通过公钥反推出私钥。这似乎还做不了什么，我们大可以通过私钥加密消息，但接收方如何通过你的公钥解密，或者验证未被篡改？如果你和接收方拥有同一对密钥，就可以通过私钥解密消息了。

ECDH 就是这样一种密钥协商算法，通过交换各自的公钥来安全地计算共同密钥对。$Alice$ 想要向 $Bob$ 发送一段消息，但是不希望被别人截获，我们需要对消息进行加密并且 $Bob$ 可以解密。 $Alice$ 显然不能直接将私钥发送给 $Bob$ ，但他们可以相互发送公钥，从而计算出一个共同密钥。流程如下：

![image.png](/zh/ecdh.png)

1. $Alice$  选取自己的私钥 $a$，计算出公钥 $A = aG$
2. $Bob$  选取自己的私钥 $b$，计算出公钥  $B=bG$
3. $Alice$ 将公钥  $A$ 发送给 $Bob$，$Bob$ 将公钥 $B$ 发送给 $A$
4. $Alice$  计算共同密钥 $K = aB$，$Bob$ 计算共同公钥 $K = bA$，因为 $aB = a(bG) = b(aG) = bA$，他们计算出的共同密钥是相同的

自此 $Alice$ 和 $Bob$ 拥有了相同的一组私钥和公钥，于是可以轻松地使用一些加密算法来共享秘密信息 $S$ 。在 TLS 中，引入了 ECDHA ，采用相同的原理生成临时密钥，使得客户端和服务器之间可以安全地传输数据。

## **ECDSA 签名**

ECDH 本质上是利用了椭圆曲线标量乘法的可交换性，它很有用，但需要双方交换密钥才能成功。如果 $Alice$ 向所有人公开了一条消息，并且需要向所有人证明这条消息确实是自己公开的。此时，所有人都成了 $Bob$ ，我们没有办法进行密钥协商。这时，你也许会想到，如果我们为所有人生成一对公共密钥，但是没有人知道私钥，并且在验证过程中消除私钥需求就可以了。

这就是 ECDSA 签名的核心逻辑，首先，我们生成一对临时公共密钥：

1. 私钥 $k$: 选取随机数 $k$，$0<k<n$
2. 公钥： $P=kG$

$Alice$ 的私钥是 $d_A$ ，对应的公钥为 $H_A$ 。我们只需要验证消息而非解密，因此只需要对消息进行哈希，因为太长我们去掉一小部分最终形成 $z$ 。$Alice$ 为了绑定消息和私钥，同时也是为了隐藏私钥，我们将 $z$ 和私钥 $h$ 相加： $z + d_A$ 。为了消除掉随机生成的 $k$ ，直觉上需要做一点除法，我们最终构造了：

$$
s=(z+d_A)k^{-1}
$$

$Alice$ 只需要公开这个 $s$ ，自己的公钥 $H_A$，消息哈希 $z$ 即可。所有人都可以通过以下计算验证签名是否正确：

$$
P=s^{-1}zG+s^{-1}H_A
$$

我们将 $H_A=d_AG$ 代入，并作一点变换就可以验证有效性：

$$
s^{-1}zG+s^{-1}H_A=s^{-1}zG+s^{-1}Gd_A=G(z+d_A)s^{-1}=Gk(z+d_A)k^{-1}s^{-1}
$$

根据 $s$ 的定义，我们得到：

$$
kGss^{-1}=kG=P
$$

恭喜你，你发明了 ECDSA 算法。 目前它在结构上是自洽的，但还是不安全，因为签名可以被伪造。攻击者想要伪造某个用户的签名，已知：

- 公钥 $H_A = d_A G$（公开）
- 消息哈希 $z$
- 签名只包含 $s$

他尝试自己构造一个签名 $s'$，让验证通过：

$$
P = s'^{-1} z G + s'^{-1} H_A
$$

我们可以因式分解这个：

$$
P = s'^{-1}(z G + H_A)
$$

然后攻击者只需要自己选一个 $s'$，再算出：

$$
P = s'^{-1}(z G + H_A) \Rightarrow P = kG
$$

这没什么难的 —— 他可以反过来直接设定 $s'$，算出对应的 $P$，就构造出了一个“合法”的签名。为此，我们需要为 $s$ 引入一下随机值 $r$ ：

$$
r=P.x \mod n
$$

即点 $P$ 的 $x$ 坐标模 $n$ ，并且需要确保不为 $0$。 $r$ 的选择还有其他考量，我们稍后再展开。新的 $s$ 为：

$$
k^{-1}(z+rd_A) 
$$

最终完整的签名流程：

1. $k$: 选取随机数 $k$，$0<k<n$
2. $P$ 的计算： $P=kG$
3. $r$ 的计算： $r=P.x \mod n$ 即点 $P$ 的 $x$ 坐标模 $n$
    1. 如 $r = 0$，则回到第一步
4. $s$ 的计算： $k^{-1}(z+rd_A)$ ，$z$ 为签名消息安全哈希后的截取
    1. 如 $s=0$，则回到第一步

验证的计算：

1. $u_1$ 的计算：$s^{-1}z \mod n$
2. $u_2$ 的计算： $s^{-1}r \mod n$
3. 验证 $P=u_1G + u_2H_A$ , $H_A$ 为签名者公钥

有效性验证：根据 $u_1$ 和 $u_2$ 的定义，以及公钥 $H_A = d_AG$，代入 $u_1G + u_2H_A$

$$
u_1G + u_2H_A = s^{-1}zG + s^{-1}rd_AG = s^{-1}(z+rd_A)G = s^{-1}(z+rd_A)k^{-1}kG
$$

根据 $s$  的定义 $s = k^{-1}(z+rd_A)$ 得 

$$
s^{-1}(z+rd_A)k^{-1}kG = s^{-1}skG = kG = P
$$

## **Schnorr 签名**

也许你对 $r$ 的引入耿耿于怀：为什么我们要从一个点中截取 $x$ 坐标？是否可以用更简单、对称的方式来构造签名？Schnorr 签名就是这样一种更优雅的方案，在理论上比 ECDSA 更优雅，在安全性上也更容易形式化证明。

Schnorr 的核心思想是：我们不再从椭圆曲线点中提取坐标，而是直接把这个点参与到哈希函数的输入中，构造一个“挑战值” $e$，并用它来结合消息与私钥。流程如下：

**签名：**

$Alice$ 拥有私钥 $d_A$，公钥 $H_A = d_A G$，她希望对消息 $m$ 进行签名。

1. 选取随机数 $k$，计算承诺点 $R = kG$
2. 计算挑战值： $e = \text{Hash}(R \parallel m)$
3. 计算响应值： $s = k + ed_A$

签名结果是二元组 $(R, s)$， $R$ 是点， $s$ 是整数。

**验证：**

任何人拥有 $Alice$ 的公钥 $H_A$ 和消息 $m$，验证方式如下：

1. 重新计算挑战值： $e = \text{Hash}(R \parallel m)$
2. 验证是否成立： $sG \stackrel{?}{=} R + eH_A$

**有效性分析：**

我们来验证上式是否成立：

$$
sG = (k + ed_A)G = kG + ed_A G = R + eH_A
$$

验证通过。

相比其他签名算法，Schnorr 的优雅性使它具有非常多的优势。它天然支持多重签名、分布式密钥生成，原理大致与 ECDH 密钥协商类似。不同的是 Schnorr 使用加法： 每个参与方首先使用各自的公钥相加生成联合公钥 $H$ （实际应用中需要加权，以防止 Rogue Key 攻击），之后生成各自的承诺 $R_i$ 、响应 $s_i$ ，所有片段加起来聚合生成最终的 $R$ 和 $s$ ，挑战为 $e = \text{Hash}(R \parallel H \parallel m)$ 。验证者验证 $sG \stackrel{?}{=} R + eH$ ，这里与单个签名相同。

Schnorr 签名因其结构对称、聚合能力强，并且安全性易于证明，但它申请了专利，因此多年来并没有得到更为广泛的应用，直到 2008 年专利才失效。Bitcoin Taproot 升级开始引入了 Schnorr 签名，以允许聚合签名以及其他更为丰富的功能。

与 ECDSA 相比，虽然 Schnorr 有一个劣势是具有可恢复性，即无法直接通过签名恢复签名者公钥。

ECDSA 的签名是一个二元组 $(r, s)$：

- 签名中的 $r$ 是从点 $R = kG$ 的 $x$ **坐标截断得来**，即 $r = R.x \mod n$
- 因为 $r$ 是从某个点 $R$ 派生而来，验证者可以**从** $r$ **倒推出** $R$ **所在的两个可能点**（由于椭圆曲线的对称性， $R$ 与 $-R$ 共享 $x$ 坐标）
- 给定 $s$、 $r$、消息哈希 $z$ ，验证者可以倒推出签名所使用的公钥 ****$H_A$

于是，有一种扩展版本的签名叫 **ECDSA 可恢复签名（ECDSA-recoverable signature）**，它在原始签名上附加一个 **recovery id**（通常是 0~3 的一个值），用来指示：

- 所使用的是 $R$ 还是 $-R$
- 是否处于主子群或倍数子群中（用于判断正确的公钥）

这 2 bit 信息配合 $(r, s)$ 即可恢复出签名者公钥。这就是为什么在以太坊的交易结构中，签名是 $(v, r, s)$，其中的 $v$ 是 recovery id（也可包含链 ID），用于恢复地址。

## 参考

- [**Elliptic Curve Cryptography: ECDH and ECDSA**](https://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/)
- [**Schnorr Digital Signature**](https://www.geeksforgeeks.org/computer-networks/schnorr-digital-signature/)
- [**Schnorr Signatures, Commitments** – UIUC Cryptography Lecture Notes](https://courses.grainger.illinois.edu/cs498ac3/fa2020/Files/Lecture_13_Scribe.pdf)
- [**To Schnorr and beyond (Part 2)** – Cryptography Engineering Blog](https://blog.cryptographyengineering.com/2023/11/30/to-schnorr-and-beyond-part-2)