# 编码

## 数据可用性编码

DAS 的核心目标是确认数据是否完整地存在于网络中，编码技术是实现这一目标的关键工具。

数据经过编码后，只要通过其中任意 50% 数据，即可恢复原始数据。这听起来很高级，实际上原理非常简单。接下来我们不得不使用一些公式，请不用走开，真的非常简单。

### 从直线说起

假设我们有一小段原始数据，将它切分为两个部分，分别用 $y_1$ 和 $y_2$ 表示，我们把它看作是在一条直线上的两个点，当 $x_1 = 1$ 和 $x_2 = 2$ 时，对应的 $y$ 值分别是 $y_1$ 和 $y_2$。根据“两点确定一条直线”的原理，我们可以画出唯一一条穿过这两点的直线，写作：

$$
y=ax+b
$$

对原始数据进行编码，就是再取 $x$ 分别为 $3,4$ 时 $y$ 的值，从而得到：

$$
[y_1,y_2,y_3,y_4]
$$

![image.png](/zh/line.png)

我们生成了一个“冗余数据集”，其中任意两个 $y$ 值就足以还原出整条直线，自然也能恢复出最初的 $y_1$ 和 $y_2$。换句话说，哪怕数据中有一半丢失，我们依然可以完整还原。

### 多项式插值与 Reed-Solomon 编码

当然，真实世界中的数据远比两个数字复杂得多，它可能是一整批交易、状态变更、合约执行等信息等等，一条简单的直线显然不够用了。但没关系，我们有更通用的表达方式：多项式插值。在编码领域，我们使用一种名为 Reed-Solomon（RS）编码的技术，它将原始数据转化为高阶多项式上的点，然后进行冗余扩展。它广泛用于光盘、硬盘、卫星通信等需要高容错的数据场景。例如当光盘有轻微的划痕时，我们还能读取出数据。只要你手上有足够多的“点”，就可以准确还原出原始数据。

应用在区块链的数据可用性中，RS 编码使得我们只需掌握一半的数据块，就可以安全地恢复区块内容，为数据可用性的检测提供了数学上的基础保障。

## 编码的正确性

现在我们回顾下采样的流程，采样者试图从网络中获得某个坐标的数据，多次采样后以获得数据是否可用的信心保证。现在还有一个问题： 我们如何确保采样获得的数据块就是发布者的原始数据块，而不是经过篡改的？

### 数据指纹

为了解决上述问题，我们需要为每个数据块生成一个唯一的指纹，我们将这种方式称为哈希（加密摘要）。然后将这些哈希两两组合，再次哈希，如此反复，最终得到一个代表所有数据块的哈希值。这就是著名的默克尔根（Merkle Root），而整个哈希结构被称为默克尔树（Merkle Tree）。

我们只需要公布从树的叶子到根经过的所有叶子，就可以验证该数据是否被经过了篡改。通过默克尔树结构，数据发布者只需公开默克尔根，其他节点即可通过极小的证明（Merkle proof）来验证每一个数据块是否属于原始数据集。这种验证机制已广泛用于比特币、以太坊等区块链中，成为链上数据认证的标准手段。

### 错误编码

默克尔树只能保证数据未被篡改，但不能判断数据是否本身就是错的。回顾一下我们的正确数据：

$$
[y_1,y_2,y_3,y_4]
$$

我们使用它来生成一个默克尔根 $root$ 。

![image.png](/zh/merkle-tree.png)

假设 $y_2$ 是一笔恶意交易，比如 Alice 只有 20 ETH，却试图向 Bob 转账 100 ETH。在乐观 Rollup 中，我们可以通过提交 $y_2$ 和对应的默克尔证明，发起挑战，使其无效。

现在 Alice 用一个错误的数据 $z$ 代替原始数据，生成新的默克尔根 $root'$ 并公开。

$$
[y_1,z,y_3,y_4]
$$

之后 Alice 隐藏数据 $z$ ，只发布其他所有数据。

![image.png](/zh/merkle-tree-fraud.png)

这样验证者仍能采样成功，误以为数据是“可用的”。但问题在于：

- 我们无法通过 $z$ 对 $root'$ 发起挑战，因为我们并不知道 $z$ 的内容；
- 我们能够恢复出 $y_2$ ，但无法生成对应 $root'$ 的证明，因为 $y_2$ 并不在新的默克尔树中。

于是，这笔恶意交易成功藏匿于看似可用的数据中，无法被识别和纠正。这只是一个思维实验，实际上只要编码是不诚实，就会带来严重的安全问题。

解决方案是使用欺诈证明。

### 欺诈证明

为防止上述情况，我们引入一个额外角色：诚实的全节点。这个强大的全节点，能够获取足够多的数据并恢复出原始数据，重新编码后生成正确的 $root$ ，即可发现 $root'$ 是错误的。一旦检测到编码错误，全节点就会生成一份欺诈证明，包含足够多的数据块及其证明，用来证明该数据批次是非法的。

网络中的采样节点在采样成功后，并不急于确认数据是可用的，而是留出一定的时间窗口等待欺诈证明传播。如果在此期间收到欺诈证明，整个数据集将被视为不可用。如果在此期间没有收到任何欺诈证明，数据才会被最终判定为可用。
这就是 DAS 结合欺诈证明机制，它为数据可用性提供了更进一步的保障。

### 多项式承诺

虽然欺诈证明机制有效，但仍有三大缺陷：

1. **依赖强力全节点**：依赖于一个强大的全节点，这增加了网络的中心化程度。少量的全节点易遭受攻击，无法发出欺诈证明，将使得不可用的数据被误认为可用。
2. **容易遭受日蚀攻击**：如果采样节点没有连接到至少一个诚实节点，将错过欺诈证明，这也被称为日蚀攻击。
3. **证明负担大**：默克尔树结构在数据量极大时，证明比数据还大。

有一个更优雅的方案可以一次性解决以上所有问题，这就是多项式承诺（Polynomial Commitment）。

回想一下恶意矿工是如何通过默克尔证明来作弊的，其构造了一个虚假的点 $(x_2, z)$ ，并和合法的数据一起生成新的默克尔根，使得系统认为错误编码的数据是可用的。本质上，这是由于默克尔树只对数据本身负责，而无法识别数据背后的直线。

多项式承诺的不同之处在于，它不是为数据生成指纹，而是为直线本身生成指纹。直线上的每个点都可以生成一个证明，我们只需要数据块、证明、承诺就可以验证其合法性，作弊者无法为一个虚假的 $z$ 生成证明来通过验证。

也就是说：

- 默克尔树是为每个数据块生成指纹；
- 多项式承诺是为“整个多项式本身”生成指纹。

在多项式承诺中，验证者只需知道：

- 某个点 $(x, y)$；
- 一份与之配套的证明；
- 以及原始的承诺值。

其中，证明的体积相对非常小，而且我们可以采用一些方式让多个数据块共用同一个证明。采用多项式承诺，我们不再需要欺诈证明，实现了真正高效、稳健的数据可用性检测。